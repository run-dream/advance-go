### 工程目录结构

#### Go 目录

- `/cmd`

  本项目的主干。入口 main.go 的所在。

- `/internal`

  私有应用程序和库代码。由 Go 编译器本身执行。

- `/pkg`

  外部应用程序可以使用的库代码。建议在有很多非 Go 应用组件时，或者项目很大的时候去使用。

- `/vendor`

  应用程序依赖项。**不要提交**。

#### 服务应用程序目录

- `/api`

  OpenAPI/Swagger 规范，JSON 模式文件，协议定义文件。

#### Web 应用程序目录

- `/web`

  特定于 Web 应用程序的组件:静态 Web 资产、服务器端模板和 SPAs。

#### 通用应用目录

- `/configs`

  配置文件模板或默认配置。

- `/scripts`

  执行各种构建、安装、分析等操作的脚本。

- `/build`

  打包和持续集成。

- `/deployments` 或 `/deploy`

  IaaS、PaaS、系统和容器编排部署配置和模板。

- `/test`

  额外的外部测试应用程序和测试数据。

#### 其他目录

- `/docs`

  设计和用户文档(除了 godoc 生成的文档之外)。

- `/tools`

  这个项目的支持工具。注意，这些工具可以从 `/pkg` 和 `/internal` 目录导入代码。

- `/examples`

  你的应用程序和/或公共库的示例。

- `/third_party`

  外部辅助工具，分叉代码和其他第三方工具。

- `/githooks`

- `/asserts`

  与存储库一起使用的其他资产(图像、徽标等)。

- `/websites`

  如果你不使用 Github 页面，则在这里放置项目的网站数据。

#### Tips

不要使用 `/src` 目录



#### 一些特定的文件

- README 说明
- CHANGELOG 变更文件
- OWNERS 维护人信息



#### 微服务服务类型

- `interface`

  对外的 BFF 服务，接受来自用户的请求，比如暴露了 HTTP/gRPC 接口。

- `service`

  对内的微服务，仅接受来自内部其他服务或者网关的请求，比如暴露了gRPC 接口只对内服务。

- `admin`

  区别于 service，更多是面向运营测的服务，通常数据权限更高，隔离带来更好的代码级别安全.

- `job`

  流式任务处理的服务，上游一般依赖 message broker。

- `task`

  定时任务，类似 cronjob，部署到 task 托管平台中。



### DDD 和 models

#### 什么是DDD

领域驱动设计 `Domain Driven Design`。

##### 分层

- `Interfaces` 接口层 主要包含与其他系统进行交互的接口与通信设施
  - `Facade` 装饰器, 为远程客户端提供粗粒度的调用接口
  - `Assembler` 装配器, DTO与领域对象之间的相互转换工作
  - `DTO` 数据传输对象 
- `Applications` 应用层
  - `Service` 只负责协调并委派业务逻辑给领域对象进行处理
- `Domain` 领域层
  - `Entity` 实体
  - `Value Objects `值对象
  - `Domain Event `领域事件
  - `Repository `仓储
- `Infrastructure`  对象持久化的具体实现
- `Aggreate Root` 最重要的以名词形式存在的领域对象

下层为上层提供服务。

##### 如何将 DDD思想应用到框架里

###### 目录映射

- `/service` 	->   `service`

- `/api` -> `DTO`

             -> `Facade` WS,REST

- `/api/errors` -> `exception`

- `/biz` -> `model`

             -> `service`

        -> `repository`

- `/data` -> `Infrastructure`

###### 松散分层架构

层间关系不那么严格。每层都可能使用它下面所有层的服务，而不仅仅是下一层的服务。每层都可能是半透明的，这意味着有些服务只对上一层可见，而有些服务对上面的所有层都可见。

###### 继承分层架构

高层继承并实现低层接口。我们需要调整一下各层的顺序，并且将基础设施层移动到最高层。
注意：继承分层架构依然是单向依赖，这也意味着领域层、应用层、表现层将不能依赖基础设施层，相反基础设施层可以依赖它们。

#### service 的模型

- 失血模型

  模型仅仅包含数据的定义和 getter/setter 方法，业务逻辑和应用逻辑都放到服务层中。POJO

- 贫血模型 **RECOMMEND**

  贫血模型中包含了一些业务逻辑，但不包含依赖持久层的业务逻辑。这部分依赖于持久层的业务逻辑将会放到服务层中。可以看出，贫血模型中的领域对象是不依赖于持久层的。

- 充血模型

  充血模型中包含了所有的业务逻辑，包括依赖于持久层的业务逻辑。所以，使用充血模型的领域层是依赖于持久层，简单表示就是 UI层->服务层->领域层<->持久层。

- 胀血模型

  胀血模型就是把和业务逻辑不想关的其他应用逻辑（如授权、事务等）都放到领域模型中。我感觉胀血模型反而是另外一种的失血模型，因为服务层消失了，领域层干了服务层的事，到头来还是什么都没变。



#### Lifecycle

Lifecycle 需要考虑服务应用的对象初始化以及生命周期的管理。我们使用 https://github.com/google/wire ，来管理所有资源的**依赖注入**。

依赖注入是为了解决

1. 方便测试
2. 单次初始化和复用；



#### Wire 的使用

1. 安装 wire

   ```bash
   go get github.com/google/wire/cmd/wire
   ```

2. 声明injector的函数签名

   ```go
   import "github.com/google/wire"
   
   // InitializeEvent 声明injector的函数签名
   func InitializeEvent(msg string) Event{
   	wire.Build(NewEvent, NewGreeter, NewMessage)
   	return Event{}  //返回值没有实际意义，只需符合函数签名即可
   }
   ```

3. 执行 wire， 生成依赖文件

   ```bash
   wire .
   ```

   得到

   ``` go
   // Code generated by Wire. DO NOT EDIT.
   
   //go:generate wire
   //+build !wireinject
   
   package main
   
   // Injectors from wire.go:
   
   func InitializeEvent(msg string) Event {
   	message := NewMessage(msg)
   	greeter := NewGreeter(message)
   	event := NewEvent(greeter)
   	return event
   }
   ```

wire 的优点是，可以少些一部分代码，同时无需再关心依赖之间的初始化顺序。

Golang 的依赖注入框架有两类，一类是通过反射在运行时进行依赖注入，典型代表是 uber 开源的 dig，另外一类是通过 generate 进行代码生成，典型代表是 Google 开源的 wire。使用 dig 功能会强大一些，但是缺点就是错误只能在运行时才能发现，这样如果不小心的话可能会导致一些隐藏的 bug 出现。使用 wire 的缺点就是功能限制多一些，但是好处就是编译的时候就可以发现问题，并且生成的代码其实和我们自己手写相关代码差不太多，更符合直觉，心智负担更小。

### API 设置

#### gRPC

- 多语言：语言中立，支持多种语言
- 轻量级、高性能：序列化支持 PB(Protocol Buffer)和 JSON，PB 是一种语言无关的高性能序列化框架。
- 可插拔
- IDL：基于文件定义服务，通过 proto3 工具生成指定语言的数据结构、服务端接口以及客户端 Stub。
- 设计理念
- 移动端：基于标准的 HTTP2 设计，支持双向流、消息头压缩、单 TCP 的多路复用、服务端推送等特性，这些特性使得 gRPC 在移动端设备上更加省电和节省网络流量
- 服务而非对象、消息而非引用：促进微服务的系统间粗粒度消息交互设计理念。
- 负载无关的：不同的服务需要使用不同的消息类型和编码，例如 protocol buffers、JSON、XML和Thrift。
- 流: Streaming API。
- 阻塞式和非阻塞式：支持异步和同步处理在客户端和服务端间交互的消息序列。
- 元数据交换：常见的横切关注点，如认证或跟踪，依赖数据交换。
- 标准化状态码：客户端通常以有限的方式响应 API 调用返回的错误。



##### API Project

- bapis 基于git + proto 文件的api管理



##### 兼容性

向后兼容(非破坏性)的修改

- 给 API 服务定义添加 API 接口
- 给请求消息添加字段
- 给响应消息添加字段

向后不兼容(破坏性)的修改

- 删除或重命名服务，字段，方法或枚举值 
- 修改字段的类型
- 修改现有请求的可见行为
- 给资源消息添加 读取/写入 字段



##### API Errors

- 使用一小组标准错误配合大量资源(http code)
- 错误传播
  - 隐藏实现详细信息和机密信息
  - 调整负责该错误的一方。



##### Api Design

FieldMask 部分更新的方案

``` protobuf
service LibraryService {
    rpc UpdateBook(UpdateBookRequest) returns (Book);
}

message UpdateBookRequest {
    Book book = 1;
    google.protobuf.FieldMask = 2;
}
```



### 配置管理

#### 分类

- 环境配置

  Region、Zone、Cluster、Environment、Color、Discovery、AppID、Host，等之类的环境信息，都是通过在线运行时平台打入到容器或者物理机，供 kit 库读取使用。

- 静态配置

  资源需要初始化的配置信息，比如 http/gRPC server、redis、mysql 等，这类资源在线变更配置的风险非常大，变更静态配置和发布 bianry app 没有区别，应该走一次迭代发布的流程。

- 动态配置

  应用程序可能需要一些在线的开关，来控制业务的一些简单策略，会频繁的调整和使用，我们把这类是基础类型(int, bool)等配置，用于可以动态变更业务流的收归一起，同时可以考虑结合类似 https://pkg.go.dev/expvar 来结合使用。

- 全局配置

  通常，我们依赖的各类组件、中间件都有大量的默认配置或者指定配置，在各个项目里大量拷贝复制，容易出现意外，所以我们使用全局配置模板来定制化常用的组件，然后再特化的应用里进行局部替换。

#### 实现

- struct 参数
- 函数选项
- 混合APIs



#### 最佳实践

##### 目标：
- 避免复杂
- 多样的配置
- 简单化努力
- 以基础设施 -> 面向用户进行转变
- 配置的必选项和可选项
- 配置的防御编程
- 权限和变更跟踪
- 配置的版本和应用对齐
- 安全的配置变更：逐步部署、回滚更改、自动回滚

### 包管理

#### 方式

- GOPATH
- Vendor
- Go Modules

#### GOPATH

历史版本的 go 语言开发时，需要将代码放在 GOPATH 目录的 src 文件夹下。

go get 命令获取依赖，也会自动下载到 GOPATH 的 src 下。

#### Go Modules

由 go.mod 和 go.sum 组成，主要包括依赖模块路径定义，以及通过 checksum 方式进行保证包的安全性。并且可以在 GOPATH 外进行创建和编译项目。



#### Go Module Proxy

- GOPROXY 代理地址
- GOPRIVATE 控制 go 命令把哪些仓库看做是私有的仓库，
  这样的话，就可以跳过 proxy server 和校验检查，这个变量的值支持用逗号分隔，可以填写多个值，例如：



### 测试

#### UnitTest

- 用 docker-compose 来解决容器依赖问题



#### 参考资料

[从PO, DTO到Domain Driven Design](https://www.cnblogs.com/allennote/articles/12345862.html)

[Golang依赖注入框架wire全攻略](https://juejin.cn/post/6844903901469097998#heading-7)